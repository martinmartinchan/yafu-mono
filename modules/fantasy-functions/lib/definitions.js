/* eslint-disable sort-keys */
export default {
  equals: {
    name: 'Setoid',
    generics: [],
    args: [ '_any' ],
    returnType: 'boolean',
  },
  lte: {
    name: 'Ord',
    generics: [],
    extending: [ 'Setoid' ],
    args: [ '_any' ],
    returnType: 'boolean',
  },
  compose: {
    name: 'Semigroupoid',
    generics: [ 'T' ],
    args: [ '_sameType<T>' ],
    returnType: 'Semigroupoid<T>',
  },
  id: {
    name: 'Category',
    generics: [ 'T' ],
    extending: [ 'Semigroupoid' ],
    args: [],
    isStatic: true,
    returnType: 'Category<T>',
  },
  concat: {
    name: 'Semigroup',
    generics: [ 'T' ],
    args: [ '_sameType<T>' ],
    returnType: 'Semigroup<T>',
  },
  empty: {
    name: 'Monoid',
    generics: [ 'T' ],
    extending: [ 'Semigroup' ],
    args: [],
    isStatic: true,
    returnType: 'Monoid<T>',
  },
  invert: {
    name: 'Group',
    generics: [ 'T' ],
    extending: [ 'Monoid' ],
    args: [],
    returnType: 'Group<T>',
  },
  filter: {
    name: 'Filterable',
    generics: [ 'T' ],
    args: [ '(x: T) => boolean' ],
    returnType: 'Filterable<T>',
  },
  map: {
    name: 'Functor',
    generics: [ 'T' ],
    args: [ '(x: T) => U' ],
    returnType: 'Functor<U>',
  },
  contramap: {
    name: 'Contravariant',
    generics: [ 'T' ],
    args: [ '(x: U) => T' ],
    returnType: 'Contravariant<U>',
  },
  ap: {
    name: 'Apply',
    generics: [ 'T' ],
    extending: [ 'Functor' ],
    args: [ '_sameType<(x: T) => U>' ],
    returnType: 'Apply<U>',
  },
  of: {
    name: 'Applicable',
    generics: [ 'T' ],
    extending: [ 'Apply' ],
    args: [ 'T' ],
    isStatic: true,
    returnType: 'Applicable<T>',
  },
  alt: {
    name: 'Alt',
    generics: [ 'T' ],
    extending: [ 'Functor' ],
    args: [ '_sameType<T>' ],
    returnType: 'Alt<T>',
  },
  zero: {
    name: 'Plus',
    generics: [ 'T' ],
    extending: [ 'Alt' ],
    args: [],
    isStatic: true,
    returnType: 'Plus<T>',
  },
  reduce: {
    name: 'Foldable',
    generics: [ 'T' ],
    args: [ '(x: U, y: T) => U', 'U' ],
    returnType: 'U',
  },
  traverse: {
    name: 'Traversible',
    generics: [ 'T' ],
    extending: [ 'Functor', 'Foldable' ],
    args: [ '_constructor:Applicable<T>', '(x: T) => U' ],
    returnType: 'Applicable<Traversible<U>>',
  },
  chain: {
    name: 'Chain',
    generics: [ 'T' ],
    extending: [ 'Apply' ],
    args: [ '(x: T) => _sameType<U>' ],
    returnType: 'Chain<U>',
  },
  chainRec: {
    name: 'ChainRec',
    generics: [ 'T' ],
    extending: [ 'Chain' ],
    args: [
      '(x: T) => U',
      '(x: U) => U',
      'T',
    ],
    returnType: 'ChainRec<U>',
    isStatic: true,
  },
  extend: {
    name: 'Extend',
    generics: [ 'T' ],
    extending: [ 'Functor' ],
    args: [ '(x: Extend<T>) => U' ],
    returnType: 'Extend<U>',
  },
  extract: {
    name: 'Comonad',
    generics: [ 'T' ],
    extending: [ 'Extend' ],
    args: [],
    returnType: 'T',
  },
  bimap: {
    name: 'Bifunctor',
    generics: [ 'T', 'U' ],
    extending: [ 'Functor' ],
    extendingGenerics: [ 'U' ],
    args: [ '(x: T) => V', '(y: U) => Z' ],
    returnType: 'Bifunctor<V, Z>',
  },
  promap: {
    name: 'Promap',
    generics: [ 'T', 'U' ],
    extending: [ 'Functor' ],
    extendingGenerics: [ 'U' ],
    args: [ '(x: V) => T', '(y: U) => Z' ],
    returnType: 'Promap<V, Z>',
  },
}
